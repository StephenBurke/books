#Dates and Times
#POSIX
#Two satndard date-time classes in R are POSIXct and POSIXlt. ct for calendar time and lt for lsit
#POSIXct is best for storing dates and calculating with them, whereas POSIXlt is best for extrcting specific parts of a date
#The function Sys.time reuturns the current date and time in POSIXct form

(now_ct <- Sys.time())

#the class now_ct has two elements. It is a POSIXct variable, and POSIXct is inherited from the clss POSIXt

class(now_ct)

#When a date is printed, you jsut see a formatted version of it, so it isn't obvious how th edtate is tored. By using unclass, we can se that it is indeed just a number

unclass(now_ct)

#When printed, the POSIXlt date looks exactly the same, but undrneath the storage mechanism is very different

(now_lt <- as.POSIXlt(now_ct))
class(now_lt)
unclass(now_lt)

#you can use list indexing to access individual components of a POSIXlt date

now_lt$sec
now_lt[["min"]]

#The date class
#Date class stores date as teh num ber of says since the start of 1970. Te date calss is best used when you dont care about the time of day. Fractional days are possible (and can be generated by clculating a mean Date, for example), but the POSIX classes are better for those situations
(now_date <- as.Date(now_ct))
class(now_date)
unclass(now_date)

#other date and time classes from add-on packages include date, dates, chron, yearmon, yearqtr, timeDate, ti, and jul

#When we read in dates from a text or spreadsheet file, they will typically be stored as a character vector or factor. To conver them to dates, we need to parse these strings. This can be done with another appallngly named function, strptime (short for "String parse time:), whcih returns POSIXlt dates. (There are as.POSIXct and as.POSIXlt functions too. If you call them on character inputs, then they are just wrappers around strptime.) To parse he dates, you must tell strptime which bits of eh string correspond to which bits of the date. The date format is specified using a string, eith components as a number is specified as %d. These components can be combined with other fixed characters - such as colons in times, or dashes and slashes in dates - to form a full specification. The time zone specificaton varies depending upon your opertiong system. It can ge complicated, so the Minutae are dicussed later, but you usually want "UTC" for universal tine or " " to use the time zne in your current locale (as determined from your operating system)

#In the follwinign exmple, %H is the hour (24-hour-system), %M is the minut, %S is the second, %m is the number of the monthe, %d is the day of the month, and %Y is the four-digit year.

moon_landings_str <- c(
	"20:17:40 20/07/1969",
	"06:54:35 19/11/1969",
	"09:18:11 05/02/1971",
	"22:16:29 30/07/1971",
	"02:23:35 21/04/1972",
	"19:54:57 11/12/1972"
	)
(moon_landing_lt <- strptime(
	moon_landing_str,
	"%H:%M:%S %d/%m/%Y",
	tz = "UTC"
	))

#If a string does not match the format in the format string, it takes the value NA. For example, specifying dashes instead of slashes makes the parsing fail

strptime(
	moon_landing_str,
	"%H:%M:%S %d-%m-%Y",
	tz = "UTC"
	)
#Formatting Dates
#The opposite problem of parsing is truning a date cariable into a string- that is, formatting it. In this case, we use the same system for specifying a format string, but now we call strftime("String format time") to reverse the parsing operation.
#In the following example, %I is the hour (12-hour system), %p is the AM?PM indicator, %A is teh full name of the day of the week, and %B is teh full name of the month. strftime works with both POSIXct adn POSIXlt inputs

strftime(now_ct, "It's %I:%M%p on %A %d %B, %Y.")

#Time Zones
#You can specify a time zone when parsing a dte string (with strptime) and change it again when you format it (with strftime). During parsing, if you don't specify a tiem sone (The default is "" ), R will give the dates a default time zone. This is the value returned by Sys.timezone, which is in turn guessed from your operating system locale settings. You can se e the OS date-time settings with Sys.getlocal("LC_TIME")
#The easiest-to-read adn most portable way of specifying time zones is to use the Olsn form, which is "Continent/City" or similar

strftime(now_ct, tz = "American/Los_Angeles")
strftime(now_ct, tz = "Africa/Brazzaville")
strftime(now_ct, tz = "Asia/Kolkata")
strftime(now_ct, tz = "Australia//Adelaide")

#The neext most reliable method is to give a manual offset from UTC, in the form "UTC"+/-n". negative tiems are east positive times are west
strftime(now_ct, tz = "UTC-5")
strftime(now_ct, tz = "GMT-5")
strftime(now_ct, tz = "-5")
strftime(now_ct, tz = "UTC+2:30")

#The third method of specifying time zon is to use an abbreviation - either three letters or three letters, a number, adn three more letters. Last resort
strftime(now_ct, tz = "EST")
strftime(now_ct, tz = "PST8PDT")

#strftime ignores time zone changes for POSIXlt dates. It is best to explicitly convert your dates to POSIXct before printing
strftime(now_ct, tz = "Asia/Tokyo")
strftime(now_ct, tz = "Asia/Tokyo")
strftime(as.POSIXct(now_lt), tz = "Asia/Tokyo")

#If you call the concatenation function, c, with a POSIXlt argument, it will change the time zone to your local time zone. Calling c on a POSIXct argument, by contrast, will strip its time zone attribute completely. (Most other functions will assume that the date is now local, but be careful)

#Aritmetic with Dates adn Times
#Adding a number to a POSIX date shifts it by that many seconds. Adding a number to a Date shifts it by that many days

now_ct + 86400		#tomorrow
now_lt + 86400		#Same behaviro for POSIXlt
now_date + 1		#Date aritmetic is in days

#can subtrate dates can't add them, will cause an error

the_start_of_time <- as.Date("1970-01-01")
the_end_of_time <- as.Date("2012-12-21")
(all_time <- the_end_of_time - the_start_of_time)

#we can use the now (hopefully) fammiliar combination of class and unclass to see how the difference in tie is stored

class(all_time)
unclass(all_time)

#The difference has class difftime, and the value is stored as a number with a unit attribute of days. Days ere automatically chosen as the "most sensible" unit dur to the difference between the times. Differences shorter than one day are given in hours, minutes, or seconds, as appropriate. For more control over the units, you can use the difftime function

difftime(the_end_of_time, the_start_of_time, units = "secs")
difftime(the_end_of_time, the_start_of_time, units = "weeks")

#The seq function for generating sequences also woks with dates. This can be particularly useful for creating test datasets of artificial dates. The choice of units in the by argument differs between the POSIX and Date types. See the ?seq.POSIXt and ?seq.Date help pages for the choices in each case

seq(the_start_of_time, the_end_of_time, by = "1 year")
seq(the_start_of_time, the_end_of_time, by = "500 days")

#Many other base functions allow manipulation of dates. yu can repeat them, round them, and cut them, You can also calculate summary statistics with mean adn methods(class = "Date"), although some other functions will handle dates without having specific date methods

#Lubridate
#to replace strptime, lubridate has a variety of parsing functions with predetermined formats. ymd accepts dates in the form year, month, day. Ther is some flexibility in the specificaton: several common separators like hyphens, forward and backward slashes, colons, and spaves can be used; months can be specified by number or by full or abbreviated name; and teh day of teh week can optionally be included. The realy beauty is that different elemetns in the same vector can have different formats (as long as teh year is followed by the month, which is followed by the day)

library(lubridate)
#the following object is masked from 'package:chron'
#days, hours, minutes, seconds, years
john_harrison_birth_date <- c(
	"1693-03 24",
	"1693/03\\24",
	"Tuesday+1693.03*24"
	)
ymd(john_harrison_birth_date)

#lubridate provide other functions (ydm, mdy, myd, dmy, and dym) for other date formats. Each of these functions has relatives that allow the specification of times as well, so you get ymd_h, ymmd_hm, and ymd_hmd, as well as the equivalents for teh other five date orderings, If your dates aren't in any of thes formats, then the lower-level parse-date_time lets you give a more exact specification
#all the parshing function in lubridate return POSIXct dates and have a default time zone of UTC. Be warnd: these behaviors are different from base R's strptime (although usually more convenient.) In lubridate temionology, these individual dates are "instants"
#For formatting dates, lubridate provides stamp, which lets you specify a formt in a more human-readable manner. You specify an example date, and it returns a function that you can call to format your dates

date_format_function <- stamp("A moon landing occurred on Monday 01 January 1900 at 18:00:00.")
date_format_function(moon_landing_lt)

#For dealing with ranges of times, lubridate has three different variable types. "Durations" specify time spans as multiples of seconds, so a duration of a day is always 86,400 seconds(60 * 60 * 24), and a duration of a year is always 31,536,000 seconds (86,400 * 365). This makes it easy to specify ranges of dates that are exactly evenly spaced, but leap years and daylight savings time put time out of sync formm clock time. In the following exaple, notive that the date slips back one day every tiem there is a leap year. today gives today's date

(duration_one_to_ten_years <- dyears(1:10))
today() + duration_one_to_ten_years

#other functions for creating durations are dseconds, dminutes, adn so forth, as well as new_duration for mixed-component specification
#"Perids" specify time spans according to clock time. Means their exact length isn't apparent until you add them to an instant.
#For example, a period of one year can be 365 or 366 days, depending upon whether or not it is a leap yaer. In the following example, notice that the date stays the same across leap years

(period_one_to_ten_years <- years(1:10))
today() + period_one_to_ten_years

#In addition to years, you can create periods with seconds, minutes, etx., as well as new_period for mixed-component specification
#"Intervals" are defined by the instants at their beginning and end. Used most commonly for specifying durations and periods when you know the start and end dates (rather than how long they should last). They can also be used for converting betwen durations and periods. For example, given a duration of one year, direct conversion to a period can only be estimated, since periods of a year can be 365 or 366 days (possibly plus a few leap seconds, and possibly plus or minus an hour or two if the rules for daylight savings change)

a_year <- dyears(1)
as.perios(a_year)

#If we know the start (or end) date of teh duration, we can use an intercal and an intermediary to conver exactly from the duration to the period

start_date <- ymd("2016-02-28")
(interval_over_leap_year <- new_interval(
	start_date,
	start_date + a_year
	))
as.period(interval_over_leap_year)

#Intervals also have some convenience operators, namely %--% for defining intervals and %within% for checking if a date is contained within an interval

ymd("2016-02-28") %--% ymd("2016-03-01")
ymd("2016-02-29") %within% interval_over_leap_year

#For dealing with time zones, with_tz lets you change the time zone of a date without having to print it (unlike strftime). I also correctly handles POSIXlt dates(again, unlike strftime)

with_tz(now_lt, tz = "America/Los_Angeles")
with_tz(now_lt, tz = "Africa/Brazzaville")
with_tz(now_lt, tz = "Asia/Kolkata")
with_tz(now_lt, tz = "Australia/Adelaide")

#force_tz is a variant of with_tz used for updating incorrect time zones
#olson_time_zones returns a lsit of all the Olson-style time zone names that R knows about, either alphabetically or by longitude

head(olson_time_zones())
head(olson_time_zones("longitude"))

#Some other utilities are available for arithmetic with dates, particularly floor_date and ceiling_date

floor_date(today(), "year")
ceiling_date(today(), "year")

#Summary
#There are three built-in classes for storing dates and times: POSIXct, POSIXlt, and Date
#Parsing turns a string into a date; it can be done with strptime
#Formatting turns a date back into a string; it can be done with strftime
#Tie zones can be specified using an Olson name or an offest from UTC, or (sometimes) with a three-letter abbreviation
#The lubridate package make working with dates a bit easier

